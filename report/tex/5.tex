%!TEX root = ../main.tex


\section{Implementation and Discussion} % (fold)
\label{sec:implementation_details}

We implement the complete protocol in Python, and opted to forego any network-related functionality in place of a local, single-instance version. Closely examining the protocol itself is more interesting than an online interactive component. The following libraries, functions, and reference code are present in the implementation:
\begin{itemize}
	\item \texttt{cryptography} -- contains AES128-GCM, HKDF, and SHA256 implementations.
	\item \texttt{hmac}, \texttt{hashlib} -- contains HMAC implementation (with alternate SHA256 object).
	\item \texttt{diffiehellman} -- contains primes and generators for multiple Diffie-Hellman groups.
	\item \texttt{os.urandom(n)} -- generates random $n$-bit byte string.
	\item \texttt{random.randint(a,b)} -- generates a random integer in the range $a,b$.
	\item \texttt{hash_table.py} -- reference hash table implementation from \cite{lind2021hash}, modified to use the hash function $h: \U \to \lbr{1,\dots,n}$.
	\item \texttt{shamir.py} -- basic Shamir secret sharing scheme, where \texttt{polynom} and \texttt{coeff} are from \cite{geek2021sha} and  \texttt{recover_secret} (and its sub-procedures) are from \cite{wiki2021sha}. 
	\item \texttt{nnhash.py} -- computes the NeuralHash of an image \cite{ygvarAppleNeuralHash2ONNX2021}.
\end{itemize}
The prime of $\F_\sh$ is the 13th Mersenne prime $2^{521} - 1$; through experimentation we determined that the 12th Mersenne prime $2^{127} - 1$ was too small, and led to incorrect reconstructions of $adkey$.

Correctness testing was performed on each cryptographic primitive, typically by fixing any randomly seeded values and verifying the output. The entire system was subjected to all possible input configurations (outlined below). Once it was fully operational, we re-introduced randomly generated values and confirmed the correctness.



The implementation is packaged with a small set of server data in \texttt{images/} and client inputs in \texttt{inputs/}. The program can be run with the following optional arguments:
\begin{itemize}
	\item \texttt{-h, --help} -- Displays argument information.
	\item \texttt{-d, --dh_num} -- Diffie-Hellman group number, default is 14.
	\item \texttt{-t, --thresh} -- Shamir secret sharing threshold $t \geq 2 $, default is $t = 3$.
	\item \texttt{-i, --image} -- Optional input image, must be placed inside \texttt{images/} directory.
\end{itemize}
By default, the program runs an experiment that demonstrates the following scenario with $t = 3$:
\begin{enumerate}{}
	\item The client submits a voucher $(y_1, id_1, ad_1)$ with $y_1 \in X$, produces a match, and updates $t'$;
	\item The client submits a duplicate voucher  $(y_1, id_1, ad_1)$ with $y_1 \in X$, produces a match, but does not update $t'$;
	\item The client submits a voucher  $(y_1, id_1', ad_1')$ with $y_1 \in X$ (see Remark~\ref{rmk:dupe}), produces a match, and updates $t'$;
	\item The client submits a duplicate voucher  $(y_2, id_2, ad_2)$ with $y_2 \nin X$, does not produce a match, and does not update $t'$;
	\item The client submits a voucher $(y_3, id_3, ad_3)$ with $y_3 \in X$, produces a match, surpasses the threshold $t$, reconstructs $adkey$, and recovers the $ad$ of all prior matches;
\end{enumerate}

A breakdown of the performance of each protocol is provided in Table~\ref{tab:performance}. As expected, the most expensive operations are multiplications and exponentiations modulo a large prime $q$. All other operations (hashing, encryption and decryption, key generation, etc.) are all lightweight with times often $<1$ ms. The {\sf S-Init} procedure needs only to be completed once for all subsequent invocations of {\sf C-Gen-Voucher} and {\sf S-Process}. It would need to be re-run in the event of adding new hashes to $X$, along with redistribution of \texttt{pdata} to all clients, but we can safely assume this is infrequent.

\begin{table}[t]
	\caption{Protocol performance for a single client input and a database with 3 images with $t = 3$, $\sh = 2^{521}-1$, and DH Group 14 (2048-bit). (*) denotes time for 3 values. {\sf C-Triple} is the time required to compute the NeuralHash of a single input image.}
	\label{tab:performance}
	\centering

	\begin{tabular}{ll|c}
	\toprule
	\textbf{Protocol} & \textbf{Steps} & \textbf{Time (ms)} \\
		\midrule
		\midrule

		 & 1-2*& 0.0301\\
		{\sf S-Init} & 3*& 20.7\\
		 & 4-9*& 70.2\\
		\midrule

		{\sf C-Init} & 1-4& 0.290 \\
		\midrule
		{\sf C-Triple} & --& 56.9 \\
		\midrule
		&  1-5 &0.364 \\
		{\sf C-Gen-Voucher}&  6 &  91.8 \\
		&  7-8  & 0.224 \\

		\midrule
		% {\sf S-Proc} & &  \\
		\multirow{4}{*}{\sf S-Proc}&1-3  &27.2 \\
		&4-8  & 0.103\\
		&9-10  & 0.000\\
		&11-17*  & 0.840\\

	\bottomrule
	\end{tabular}
\end{table}